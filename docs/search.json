[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "A Characterization of the Australian Financial Assistance Grants System",
    "section": "",
    "text": "Preface\nThis is a Quarto book.\nTo learn more about Quarto books visit https://quarto.org/docs/books.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "intro.html",
    "href": "intro.html",
    "title": "1  Introduction",
    "section": "",
    "text": "This is a book created from markdown and executable code.\nSee Knuth (1984) for additional discussion of literate programming.\n\n\n\n\nKnuth, Donald E. 1984. “Literate Programming.” Comput. J. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction</span>"
    ]
  },
  {
    "objectID": "methodology.html",
    "href": "methodology.html",
    "title": "2  FA Grant Allocation Methodology",
    "section": "",
    "text": "2.1 At the Federal Level\n30% of the General Purpose Component grant is allocated on a per capita basis.\nGeneral Purpose Component - Allocation to states on a per capital basis Roads Component - Allocation to states based on fixed ratios:",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>FA Grant Allocation Methodology</span>"
    ]
  },
  {
    "objectID": "methodology.html#at-the-federal-level",
    "href": "methodology.html#at-the-federal-level",
    "title": "2  FA Grant Allocation Methodology",
    "section": "",
    "text": "State\nRoads Component %\n\n\n\n\nNew South Wales\n29.0%\n\n\nVictoria\n20.6%\n\n\nQueensland\n18.7%\n\n\nSouth Australia\n5.5%\n\n\nWestern Australia\n15.3%\n\n\nTasmania\n5.3%\n\n\nNorthern Territory\n2.3%\n\n\nAustralian Capital Territory\n3.2%\n\n\n\n\nNSW, WA, SA : Population &gt; 50,000 -&gt; Minimum grant council",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>FA Grant Allocation Methodology</span>"
    ]
  },
  {
    "objectID": "methodology.html#new-south-wales",
    "href": "methodology.html#new-south-wales",
    "title": "2  FA Grant Allocation Methodology",
    "section": "2.2 New South Wales",
    "text": "2.2 New South Wales",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>FA Grant Allocation Methodology</span>"
    ]
  },
  {
    "objectID": "methodology.html#victoria",
    "href": "methodology.html#victoria",
    "title": "2  FA Grant Allocation Methodology",
    "section": "2.3 Victoria",
    "text": "2.3 Victoria\n\nhttps://www.localgovernment.vic.gov.au/funding-programs/victoria-grants-commission/financial-assistance-grants https://www.localgovernment.vic.gov.au/funding-programs/victoria-grants-commission/publications https://www.localgovernment.vic.gov.au/__data/assets/pdf_file/0019/210727/2024-25-VLGGC-Annual-Allocation-Report-Sept-2024.pdf",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>FA Grant Allocation Methodology</span>"
    ]
  },
  {
    "objectID": "methodology.html#queensland",
    "href": "methodology.html#queensland",
    "title": "2  FA Grant Allocation Methodology",
    "section": "2.4 Queensland",
    "text": "2.4 Queensland\n\nhttps://www.localgovernment.qld.gov.au/for-councils/governance/queensland-local-government-grants-commission/financial-assistance-grant https://www.localgovernment.qld.gov.au/__data/assets/pdf_file/0030/99174/commission-report-2024.pdf\n\nPopulation &gt; 80,000 -&gt; Minimum grant council",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>FA Grant Allocation Methodology</span>"
    ]
  },
  {
    "objectID": "methodology.html#south-australia",
    "href": "methodology.html#south-australia",
    "title": "2  FA Grant Allocation Methodology",
    "section": "2.5 South Australia",
    "text": "2.5 South Australia\n\nhttps://dit.sa.gov.au/local-government/grants-commission/methodology-review https://www.dit.sa.gov.au/local-government/grants-commission/general-purpose-grants https://www.dit.sa.gov.au/local-government/documents/office-of-local-government/grants-commission/general_purpose_grants-adelaide-holdfast_bay.pdf https://www.dit.sa.gov.au/local-government/grants-commission/publications https://www.dit.sa.gov.au/__data/assets/pdf_file/0008/1275470/Database-Reports-2021-22.pdf",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>FA Grant Allocation Methodology</span>"
    ]
  },
  {
    "objectID": "methodology.html#western-australia",
    "href": "methodology.html#western-australia",
    "title": "2  FA Grant Allocation Methodology",
    "section": "2.6 Western Australia",
    "text": "2.6 Western Australia\n\nhttps://www.dlgsc.wa.gov.au/local-government/local-governments/financial-assistance-grants",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>FA Grant Allocation Methodology</span>"
    ]
  },
  {
    "objectID": "methodology.html#tasmania",
    "href": "methodology.html#tasmania",
    "title": "2  FA Grant Allocation Methodology",
    "section": "2.7 Tasmania",
    "text": "2.7 Tasmania\n\nhttps://www.treasury.tas.gov.au/state-grants-commission/publications https://www.treasury.tas.gov.au/Documents/State%20Grants%20Commission%20Annual%20Report%202023-24.pdf https://www.treasury.tas.gov.au/Documents/State%20Grants%20Commission%202024-25%20Financial%20Assistance%20Grant%20Data%20Tables.pdf",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>FA Grant Allocation Methodology</span>"
    ]
  },
  {
    "objectID": "methodology.html#northern-territory",
    "href": "methodology.html#northern-territory",
    "title": "2  FA Grant Allocation Methodology",
    "section": "2.8 Northern Territory",
    "text": "2.8 Northern Territory\n\nThe 2023-34 allocation data tables are used since the annual report is not out yet.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>FA Grant Allocation Methodology</span>"
    ]
  },
  {
    "objectID": "methodology.html#australian-capital-territory",
    "href": "methodology.html#australian-capital-territory",
    "title": "2  FA Grant Allocation Methodology",
    "section": "2.9 Australian Capital Territory",
    "text": "2.9 Australian Capital Territory",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>FA Grant Allocation Methodology</span>"
    ]
  },
  {
    "objectID": "NSW_methodology.html",
    "href": "NSW_methodology.html",
    "title": "4  New South Wales Methodology",
    "section": "",
    "text": "This is the content for # New South Wales Methodology.",
    "crumbs": [
      "Where we stand",
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>New South Wales Methodology</span>"
    ]
  },
  {
    "objectID": "VIC_methodology.html",
    "href": "VIC_methodology.html",
    "title": "5  Victoria Methodology",
    "section": "",
    "text": "This is the content for # Victoria Methodology.",
    "crumbs": [
      "Where we stand",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>Victoria Methodology</span>"
    ]
  },
  {
    "objectID": "QLD_methodology.html",
    "href": "QLD_methodology.html",
    "title": "6  Queensland Methodology",
    "section": "",
    "text": "This is the content for # Queensland Methodology.",
    "crumbs": [
      "Where we stand",
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>Queensland Methodology</span>"
    ]
  },
  {
    "objectID": "SA_methodology.html",
    "href": "SA_methodology.html",
    "title": "7  South Australia Methodology",
    "section": "",
    "text": "This is the content for # South Australia Methodology.",
    "crumbs": [
      "Where we stand",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>South Australia Methodology</span>"
    ]
  },
  {
    "objectID": "WA_methodology.html",
    "href": "WA_methodology.html",
    "title": "8  Western Australia Methodology",
    "section": "",
    "text": "This is the content for # Western Australia Methodology.",
    "crumbs": [
      "Where we stand",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>Western Australia Methodology</span>"
    ]
  },
  {
    "objectID": "TAS_methodology.html",
    "href": "TAS_methodology.html",
    "title": "9  Tasmania Methodology",
    "section": "",
    "text": "This is the content for # Tasmania Methodology.",
    "crumbs": [
      "Where we stand",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>Tasmania Methodology</span>"
    ]
  },
  {
    "objectID": "NT_methodology.html",
    "href": "NT_methodology.html",
    "title": "10  Northern Territory Methodology",
    "section": "",
    "text": "This is the content for # Northern Territory Methodology.",
    "crumbs": [
      "Where we stand",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>Northern Territory Methodology</span>"
    ]
  },
  {
    "objectID": "discussed-issues.html",
    "href": "discussed-issues.html",
    "title": "11  Discussed Issues",
    "section": "",
    "text": "This is the content for # Discussed Issues.",
    "crumbs": [
      "A peek into the problems",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>Discussed Issues</span>"
    ]
  },
  {
    "objectID": "methodology-detailed.html",
    "href": "methodology-detailed.html",
    "title": "12  Detailed Methodology",
    "section": "",
    "text": "This is the content for # Detailed Methodology.",
    "crumbs": [
      "Data Data Data",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Detailed Methodology</span>"
    ]
  },
  {
    "objectID": "methodology-simplified.html",
    "href": "methodology-simplified.html",
    "title": "13  Simplified Methodology",
    "section": "",
    "text": "This is the content for # Simplified Methodology.",
    "crumbs": [
      "Data Data Data",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>Simplified Methodology</span>"
    ]
  },
  {
    "objectID": "lower_min_grant.html",
    "href": "lower_min_grant.html",
    "title": "13  A 17% Per Capita Minimum Grant",
    "section": "",
    "text": "The model here applies a per capita minimum grant constraint, set at 17%, to ensure that each jurisdiction receives at least this proportion of the funds if they were allocated on a per capita basis.\nThe per capita minimum for the benchmark scenario is set to 30%, as is the status quo.\n\n\nfrom fagrants_module import fagrants\n\ninst = fagrants.fagrants_model(\n    data_path = \"./Data/FA Grants Tables - Python.xlsx\", \n    per_capita_minimum = 0.17,\n    per_capita_minimum_base = 0.3\n)\nsim_grants = inst.run()\n\n\nsim_grants[\"Sim_i\"] = sim_grants[\"UID\"].str.split(\"_\").str[1].astype(str)\n\n\nsim_grants\n\n\n\n\n\n\n\n\nJurisdiction\nLGA\nACLG\nUID\nERP_2024\nGrant_2024\nERP_2025\nGrant_base_2025\nGrant_2025\nERP_2026\nGrant_base_2026\nGrant_2026\nERP_2027\nGrant_base_2027\nGrant_2027\nERP_2028\nGrant_base_2028\nGrant_2028\nSim_i\n\n\n\n\n0\nNew South Wales\nThe Council of the City of Sydney\nUCC\nTheCounciloftheCityofSydney_1\n231086\n5901858\n238154.0\n6.198876e+06\n3.512696e+06\n240869.0\n6.429082e+06\n3.643147e+06\n243445.0\n6.663437e+06\n3.775948e+06\n246049.0\n6.903611e+06\n3.912046e+06\n1\n\n\n1\nNew South Wales\nHunter's Hill Council\nUDS\nHunter'sHillCouncil_1\n14036\n441211\n14465.0\n4.585883e+05\n3.106787e+05\n14630.0\n4.818269e+05\n3.295757e+05\n14787.0\n4.928998e+05\n3.338842e+05\n14945.0\n5.212085e+05\n3.584223e+05\n1\n\n\n2\nNew South Wales\nMosman Municipal Council\nUDM\nMosmanMunicipalCouncil_1\n29071\n908679\n29960.0\n9.480184e+05\n6.413304e+05\n30302.0\n9.819493e+05\n6.636276e+05\n30626.0\n1.025383e+06\n6.968779e+05\n30953.0\n1.090693e+06\n7.556230e+05\n1\n\n\n3\nNew South Wales\nBurwood Council\nUDM\nBurwoodCouncil_1\n42498\n1136510\n43798.0\n1.196932e+06\n7.134981e+05\n44297.0\n1.235242e+06\n7.327194e+05\n44771.0\n1.270678e+06\n7.480510e+05\n45250.0\n1.318094e+06\n7.769286e+05\n1\n\n\n4\nNew South Wales\nLane Cove Municipal Council\nUDM\nLaneCoveMunicipalCouncil_1\n41549\n1123412\n42820.0\n1.179224e+06\n7.082598e+05\n43308.0\n1.223445e+06\n7.350727e+05\n43771.0\n1.261218e+06\n7.537792e+05\n44239.0\n1.301400e+06\n7.746948e+05\n1\n\n\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n...\n\n\n537995\nNorthern Territory\nTiwi Islands Regional Council\nRTM\nTiwiIslandsRegionalCouncil_1000\n2763\n450412\n2887.0\n5.626662e+05\n6.206389e+05\n2910.0\n7.182112e+05\n8.036014e+05\n2921.0\n7.915454e+05\n8.890983e+05\n2944.0\n8.845674e+05\n9.977177e+05\n1000\n\n\n537996\nNorthern Territory\nVictoria Daly Regional Council\nRTL\nVictoriaDalyRegionalCouncil_1000\n3314\n589064\n3463.0\n5.787290e+05\n6.304029e+05\n3490.0\n6.382656e+05\n6.992433e+05\n3504.0\n7.076615e+05\n7.797667e+05\n3531.0\n6.652054e+05\n7.274230e+05\n1000\n\n\n537997\nNorthern Territory\nWagait Shire Council\nRTS\nWagaitShireCouncil_1000\n467\n12407\n488.0\n1.270314e+04\n7.198447e+03\n492.0\n1.310739e+04\n7.427519e+03\n494.0\n1.350900e+04\n7.655100e+03\n498.0\n1.397056e+04\n7.916649e+03\n1000\n\n\n537998\nNorthern Territory\nWest Arnhem Regional Council\nRTL\nWestArnhemRegionalCouncil_1000\n7449\n1953690\n7785.0\n1.867657e+06\n2.089056e+06\n7845.0\n1.713549e+06\n1.902399e+06\n7875.0\n1.668137e+06\n1.844621e+06\n7936.0\n1.742932e+06\n1.928800e+06\n1000\n\n\n537999\nNorthern Territory\nWest Daly Regional Council\nRTL\nWestDalyRegionalCouncil_1000\n3445\n579827\n3600.0\n6.601503e+05\n7.247376e+05\n3628.0\n6.820488e+05\n7.488817e+05\n3642.0\n6.896878e+05\n7.561188e+05\n3670.0\n7.705074e+05\n8.498672e+05\n1000\n\n\n\n\n538000 rows × 19 columns\n\n\n\n\nfor year in range(2025, 2029):\n    sim_grants[f\"Grant Delta_{year}\"] = sim_grants[f\"Grant_{year}\"] - sim_grants[f\"Grant_base_{year}\"]\n\n\nsim_grants_udl = sim_grants[sim_grants[\"ACLG\"] == \"UDL\"].copy()\n\n\nsim_grants_udl.groupby(\"Jurisdiction\")\n\n&lt;pandas.core.groupby.generic.DataFrameGroupBy object at 0x70c3590b3790&gt;\n\n\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n\ndef monte_carlo_plot(data)\n\n\ng = sns.FacetGrid(sim_grants_udl, row=\"Jurisdiction\")",
    "crumbs": [
      "Data Data Data",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>A 17% Per Capita Minimum Grant</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Knuth, Donald E. 1984. “Literate Programming.” Comput.\nJ. 27 (2): 97–111. https://doi.org/10.1093/comjnl/27.2.97.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "simulation_methodology.html",
    "href": "simulation_methodology.html",
    "title": "12  Methodology: Grants Simulation",
    "section": "",
    "text": "12.1 Controls and constants\nThis notebook simulates the allocation of Financial Assistance Grants to Australian states and territories. For each region, the methodology is explained in markdown cells preceding the code implementation. The following explanations are inserted above each code cell for clarity.\nThis cell imports essential libraries for data manipulation and numerical operations, specifically pandas and numpy. It also disables chained assignment warnings in pandas to streamline data processing.\nper_capita_minimum = 0.17\nper_capita_minimum_base = 0.3\nThis cell defines key constants used throughout the simulation, including the per capita minimum grant rates. These values serve as baseline parameters for grant calculations in subsequent analyses.\npop_30_jun = pd.read_excel(\"../Data/FA Grants Tables - Python.xlsx\", sheet_name=\"Population\", skiprows=9, nrows=7)\n\npop_30_jun.set_index(\"Population by state, at 30 June (million)\", inplace=True)\n\npop_30_jun = pop_30_jun * 1e6\nThis cell loads population data for each state from an Excel file, sets the appropriate index, and scales the values to actual population numbers. This data is fundamental for calculating grant allocations based on population.\nbudget_grants = pd.read_excel(\"../Data/FA Grants Tables - Python.xlsx\", sheet_name = \"Grants\")\n\nbudget_grants.bfill(inplace=True)\n\nbudget_grants.set_index(\"Financial Assistance Grant program (million)\", inplace=True)\n\nbudget_grants = budget_grants.loc[[\"2025-26\", \"2026-27\", \"2027-28\", \"2028-29\"]]\n\nbudget_grants = budget_grants * 1e6\nThis cell reads the projected grant budget for each state from an Excel file, fills missing values, sets the index, and selects relevant years. The resulting data frame provides the total grant pool available for distribution in each simulation year.",
    "crumbs": [
      "Data Data Data",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Methodology: Grants Simulation</span>"
    ]
  },
  {
    "objectID": "simulation_methodology.html#new-south-wales",
    "href": "simulation_methodology.html#new-south-wales",
    "title": "12  Methodology: Grants Simulation",
    "section": "12.2 New South Wales",
    "text": "12.2 New South Wales\nAbsense of reliable documentation means that we use the same approach as used in Queensland’s modelling.\n\nnsw_grants_base = pd.read_excel(\"../Data/FA Grants Tables - Python.xlsx\", sheet_name=\"New South Wales\")\n\nnsw_grants_base[\"ERP_2025\"] = nsw_grants_base[\"ERP_2024\"] * pop_30_jun[\"NSW\"][2025] / nsw_grants_base[\"ERP_2024\"].sum()\nnsw_grants_base[\"ERP_2025\"] = nsw_grants_base[\"ERP_2025\"].round(0)\n\nnsw_grants_base[\"ERP_2026\"] = nsw_grants_base[\"ERP_2024\"] * pop_30_jun[\"NSW\"][2026] / nsw_grants_base[\"ERP_2024\"].sum()\nnsw_grants_base[\"ERP_2026\"] = nsw_grants_base[\"ERP_2026\"].round(0)\n\nnsw_grants_base[\"ERP_2027\"] = nsw_grants_base[\"ERP_2024\"] * pop_30_jun[\"NSW\"][2027] / nsw_grants_base[\"ERP_2024\"].sum()\nnsw_grants_base[\"ERP_2027\"] = nsw_grants_base[\"ERP_2027\"].round(0)\n\nnsw_grants_base[\"ERP_2028\"] = nsw_grants_base[\"ERP_2024\"] * pop_30_jun[\"NSW\"][2028] / nsw_grants_base[\"ERP_2024\"].sum()\nnsw_grants_base[\"ERP_2028\"] = nsw_grants_base[\"ERP_2028\"].round(0)\n\nnew_south_wales_master_sim = pd.DataFrame()\n\nfor i in range(1000):\n    nsw_grants = nsw_grants_base.copy()\n\n    nsw_grants[\"UID\"] = nsw_grants[\"LGA\"].str.replace(\" \", \"\").replace(\"-\", \"\") + str(i+1)\n\n    for year in range(2025, 2027):\n        prev_year = year - 1\n\n        min_per_capita_grant = budget_grants[\"NSW\"][f\"{year}-{(year+1)%1000}\"] / nsw_grants[f\"ERP_{year}\"].sum() * per_capita_minimum\n\n        min_grant = nsw_grants[f\"ERP_{year}\"] * min_per_capita_grant\n\n        min_per_capita_grant_base = budget_grants[\"NSW\"][f\"{year}-{(year+1)%1000}\"] / nsw_grants[f\"ERP_{year}\"].sum() * per_capita_minimum_base\n\n        min_grant_base = nsw_grants[f\"ERP_{year}\"] * min_per_capita_grant_base\n\n        non_min = nsw_grants[f\"Scaled Gap_{year-1}\"].round(4) == 0.0\n\n        nsw_grants[f\"Scaled Gap_{year}\"] = (nsw_grants[f\"Scaled Gap_{year-1}\"] * np.random.normal(1, 0.1, size=nsw_grants.shape[0]))# * non_min\n        nsw_grants[f\"Scaled Gap_{year}\"] = nsw_grants[f\"Scaled Gap_{year}\"]/nsw_grants[f\"Scaled Gap_{year}\"].sum()\n\n        # New case\n\n        raw_alloc = nsw_grants[f\"Scaled Gap_{year}\"] * (budget_grants[\"NSW\"][f\"{year}-{(year+1)%1000}\"] - min_grant.sum())\n\n        nsw_grants[f\"Grant_{year}\"] = min_grant + raw_alloc\n\n        # Base case\n\n        raw_alloc = nsw_grants[f\"Scaled Gap_{year}\"] * (budget_grants[\"NSW\"][f\"{year}-{(year+1)%1000}\"] - min_grant_base.sum())\n\n        nsw_grants[f\"Grant_base_{year}\"] = min_grant_base + raw_alloc\n\n    new_south_wales_master_sim = pd.concat([new_south_wales_master_sim, nsw_grants])\n\nThis cell simulates grant allocations for New South Wales using a methodology similar to Queensland’s due to limited documentation. It projects population, calculates minimum grants, and allocates the remaining budget based on scaled gaps, running 1000 simulations to capture variability.",
    "crumbs": [
      "Data Data Data",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Methodology: Grants Simulation</span>"
    ]
  },
  {
    "objectID": "simulation_methodology.html#victoria",
    "href": "simulation_methodology.html#victoria",
    "title": "12  Methodology: Grants Simulation",
    "section": "12.3 Victoria",
    "text": "12.3 Victoria\nVictoria OLG has a cap/collar of [2%, 10%] for non minimum grant councils.\n\ndef correct_delta_vic(sub_vic, year, base = False):\n\n    total_funding_gap =  (sub_vic[f\"Funding Gap_{year}\"] * sub_vic[\"deficit\"]).sum()\n    total_funding = sub_vic[\"alloc\"].sum()\n\n    comparison_column = \"Grant_base_\" if base else \"Grant_\"\n    \n    while np.any((sub_vic[\"delta\"].round(2)&lt;2)|(sub_vic[\"delta\"].round(2)&gt;10)):\n        sub_vic[\"g\"] = sub_vic[\"delta\"].apply(lambda x: (x - 2)/100 if x &lt; 2 else ((x - 10)/100 if x &gt; 10 else 0))\n\n        sub_vic[\"alloc\"] -= sub_vic[\"g\"] * sub_vic[f\"{comparison_column}{year-1}\"]\n\n        remainder = total_funding - sub_vic[\"alloc\"].sum()\n\n        sub_vic[\"alloc\"] += sub_vic[f\"Funding Gap_{year}\"] * remainder / total_funding_gap\n\n        sub_vic[\"delta\"] = (sub_vic[\"alloc\"] - sub_vic[f\"{comparison_column}{year-1}\"]) / sub_vic[f\"{comparison_column}{year-1}\"] * 100\n    return sub_vic\n\nThis function enforces Victoria’s cap/collar policy, ensuring that non-minimum grant councils’ year-on-year changes remain within the [2%, 10%] range. It iteratively adjusts allocations to comply with these constraints.\n\nvic_grants_base = pd.read_excel(\"../Data/FA Grants Tables - Python.xlsx\", sheet_name=\"Victoria\")\n\nvic_grants_base[\"ERP_2025\"] = vic_grants_base[\"ERP_2024\"] * pop_30_jun[\"VIC\"][2025] / vic_grants_base[\"ERP_2024\"].sum()\nvic_grants_base[\"ERP_2025\"] = vic_grants_base[\"ERP_2025\"].round(0)\n\nvic_grants_base[\"ERP_2026\"] = vic_grants_base[\"ERP_2024\"] * pop_30_jun[\"VIC\"][2026] / vic_grants_base[\"ERP_2024\"].sum()\nvic_grants_base[\"ERP_2026\"] = vic_grants_base[\"ERP_2026\"].round(0)\n\nvic_grants_base[\"ERP_2027\"] = vic_grants_base[\"ERP_2024\"] * pop_30_jun[\"VIC\"][2027] / vic_grants_base[\"ERP_2024\"].sum()\nvic_grants_base[\"ERP_2027\"] = vic_grants_base[\"ERP_2027\"].round(0)\n\nvic_grants_base[\"ERP_2028\"] = vic_grants_base[\"ERP_2024\"] * pop_30_jun[\"VIC\"][2028] / vic_grants_base[\"ERP_2024\"].sum()\nvic_grants_base[\"ERP_2028\"] = vic_grants_base[\"ERP_2028\"].round(0)\n\nvic_grants_base[\"Grant_base_2024\"] = vic_grants_base[\"Grant_2024\"]\n\nvictoria_master_sim = pd.DataFrame()\n\nThis cell simulates grant allocations for Victoria, applying the cap/collar function to non-minimum grant councils. It projects population, calculates minimum grants, and distributes the remaining budget based on funding gaps, running 1000 simulations.\n\nfor i in range(1000):\n\n    vic_grants = vic_grants_base.copy()\n\n    vic_grants[\"UID\"] = vic_grants[\"LGA\"].str.replace(\" \", \"\").replace(\"-\", \"\") + str(i+1)\n\n    for year in range(2025, 2029):\n\n        prev_year = year - 1\n\n        min_per_capita_grant = budget_grants[\"VIC\"][f\"{year}-{(year+1)%1000}\"] / vic_grants[f\"ERP_{year}\"].sum() * per_capita_minimum\n\n        min_grant = vic_grants[f\"ERP_{year}\"] * min_per_capita_grant\n\n        min_per_capita_grant_base = budget_grants[\"VIC\"][f\"{year}-{(year+1)%1000}\"] / vic_grants[f\"ERP_{year}\"].sum() * per_capita_minimum_base\n\n        min_grant_base = vic_grants[f\"ERP_{year}\"] * min_per_capita_grant_base\n\n        vic_grants[f\"Funding Gap_{year}\"] = vic_grants[f\"Funding Gap_{year-1}\"] * np.random.normal(1, 0.1, size=vic_grants.shape[0])\n\n        vic_grants[\"deficit\"] = vic_grants[f\"Funding Gap_{year}\"] &gt; 0\n\n        total_deficit = (vic_grants[f\"Funding Gap_{year}\"] * vic_grants[\"deficit\"]).sum()\n\n        # New case\n\n        raw_alloc = (vic_grants[f\"Funding Gap_{year}\"] * vic_grants[\"deficit\"] / total_deficit) * (budget_grants[\"VIC\"][f\"{year}-{(year+1)%1000}\"] - min_grant.sum())\n\n        vic_grants[\"alloc\"] = min_grant + raw_alloc\n\n        vic_grants[\"delta\"] = (vic_grants[\"alloc\"] - vic_grants[f\"Grant_{year-1}\"]) / vic_grants[f\"Grant_{year-1}\"] * 100\n\n        non_min_vic = vic_grants[vic_grants[\"deficit\"]]#[[\"LGA\", f\"Funding Gap_{year}\", f\"grant_{year-1}\", \"alloc\"]]\n\n        vic_grants.combine_first(correct_delta_vic(non_min_vic, year))\n\n        vic_grants[f\"Grant_{year}\"] = vic_grants[\"alloc\"]\n\n\n        # Base case\n\n        raw_alloc = (vic_grants[f\"Funding Gap_{year}\"] * vic_grants[\"deficit\"] / total_deficit) * (budget_grants[\"VIC\"][f\"{year}-{(year+1)%1000}\"] - min_grant_base.sum())\n\n        vic_grants[\"alloc\"] = min_grant_base + raw_alloc\n\n        vic_grants[\"delta\"] = (vic_grants[\"alloc\"] - vic_grants[f\"Grant_base_{year-1}\"]) / vic_grants[f\"Grant_base_{year-1}\"] * 100\n\n        non_min_vic = vic_grants[vic_grants[\"deficit\"]]#[[\"LGA\", f\"Funding Gap_{year}\", f\"grant_{year-1}\", \"alloc\"]]\n\n        vic_grants.combine_first(correct_delta_vic(non_min_vic, year, base=True))\n\n        vic_grants[f\"Grant_base_{year}\"] = vic_grants[\"alloc\"]\n    \n    victoria_master_sim = pd.concat([victoria_master_sim, vic_grants])",
    "crumbs": [
      "Data Data Data",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Methodology: Grants Simulation</span>"
    ]
  },
  {
    "objectID": "simulation_methodology.html#queensland",
    "href": "simulation_methodology.html#queensland",
    "title": "12  Methodology: Grants Simulation",
    "section": "12.4 Queensland",
    "text": "12.4 Queensland\nQueensland does not release their “Funding Gap” variable. Hence, an analogue is reverse engineered from the gap between grant entitlement and minimum grant. Adjustments and normalizations applied to this should, in principle, give fairly robust numbers, especially at the high level.\nThere’s no cap/collar and minimum grant eligibility is based on population &gt; 80,000.\n\nqld_grants_base = pd.read_excel(\"../Data/FA Grants Tables - Python.xlsx\", sheet_name=\"Queensland\")\n\nqld_grants_base[\"ERP_2025\"] = qld_grants_base[\"ERP_2024\"] * pop_30_jun[\"QLD\"][2025] / qld_grants_base[\"ERP_2024\"].sum()\nqld_grants_base[\"ERP_2025\"] = qld_grants_base[\"ERP_2025\"].round(0)\n\nqld_grants_base[\"ERP_2026\"] = qld_grants_base[\"ERP_2024\"] * pop_30_jun[\"QLD\"][2026] / qld_grants_base[\"ERP_2024\"].sum()\nqld_grants_base[\"ERP_2026\"] = qld_grants_base[\"ERP_2026\"].round(0)\n\nqld_grants_base[\"ERP_2027\"] = qld_grants_base[\"ERP_2024\"] * pop_30_jun[\"QLD\"][2027] / qld_grants_base[\"ERP_2024\"].sum()\nqld_grants_base[\"ERP_2027\"] = qld_grants_base[\"ERP_2027\"].round(0)\n\nqld_grants_base[\"ERP_2028\"] = qld_grants_base[\"ERP_2024\"] * pop_30_jun[\"QLD\"][2028] / qld_grants_base[\"ERP_2024\"].sum()\nqld_grants_base[\"ERP_2028\"] = qld_grants_base[\"ERP_2028\"].round(0)\n\nqueensland_master_sim = pd.DataFrame()\n\nfor i in range(1000):\n    qld_grants = qld_grants_base.copy()\n\n    qld_grants[\"UID\"] = qld_grants[\"LGA\"].str.replace(\" \", \"\").replace(\"-\", \"\") + str(i+1)\n\n    for year in range(2025, 2029):\n        prev_year = year - 1\n\n        min_per_capita_grant = budget_grants[\"QLD\"][f\"{year}-{(year+1)%1000}\"] / qld_grants[f\"ERP_{year}\"].sum() * per_capita_minimum\n\n        min_grant = qld_grants[f\"ERP_{year}\"] * min_per_capita_grant\n\n        min_per_capita_grant_base = budget_grants[\"QLD\"][f\"{year}-{(year+1)%1000}\"] / qld_grants[f\"ERP_{year}\"].sum() * per_capita_minimum_base\n\n        min_grant_base = qld_grants[f\"ERP_{year}\"] * min_per_capita_grant_base\n\n        non_min = qld_grants[f\"ERP_{year}\"] &lt;= 80000\n\n        qld_grants[f\"Scaled Gap_{year}\"] = (qld_grants[f\"Scaled Gap_{year-1}\"] * np.random.normal(1, 0.1, size=qld_grants.shape[0])) * non_min\n        qld_grants[f\"Scaled Gap_{year}\"] = qld_grants[f\"Scaled Gap_{year}\"]/qld_grants[f\"Scaled Gap_{year}\"].sum()\n\n        # New case\n\n        raw_alloc = qld_grants[f\"Scaled Gap_{year}\"] * (budget_grants[\"QLD\"][f\"{year}-{(year+1)%1000}\"] - min_grant.sum())\n\n        qld_grants[f\"Grant_{year}\"] = min_grant + raw_alloc\n\n        # Base case\n\n        raw_alloc = qld_grants[f\"Scaled Gap_{year}\"] * (budget_grants[\"QLD\"][f\"{year}-{(year+1)%1000}\"] - min_grant_base.sum())\n\n        qld_grants[f\"Grant_base_{year}\"] = min_grant_base + raw_alloc\n\n    queensland_master_sim = pd.concat([queensland_master_sim, qld_grants])\n\nThis cell simulates grant allocations for Queensland, where the funding gap is reverse engineered due to lack of direct data. Minimum grant eligibility is based on population, and there are no cap/collar constraints. The simulation runs 1000 iterations to model variability.",
    "crumbs": [
      "Data Data Data",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Methodology: Grants Simulation</span>"
    ]
  },
  {
    "objectID": "simulation_methodology.html#south-australia",
    "href": "simulation_methodology.html#south-australia",
    "title": "12  Methodology: Grants Simulation",
    "section": "12.5 South Australia",
    "text": "12.5 South Australia\nSouth Australia OLG has a cap/collar of [-15%, 30%] for councils.\n\ndef correct_delta_sa(sub_sa, year, base = False):\n\n    total_funding_gap =  (sub_sa[f\"Funding Gap_{year}\"] * sub_sa[\"deficit\"]).sum()\n    total_funding = sub_sa[\"alloc\"].sum()\n\n    comparison_column = \"Grant_base_\" if base else \"Grant_\"\n    \n    while np.any((sub_sa[\"delta\"].round(2)&lt;-15)|(sub_sa[\"delta\"].round(2)&gt;30)):\n        sub_sa[\"g\"] = sub_sa[\"delta\"].apply(lambda x: (x - (-15))/100 if x &lt; -15 else ((x - 30)/100 if x &gt; 30 else 0))\n\n        sub_sa[\"alloc\"] -= sub_sa[\"g\"] * sub_sa[f\"{comparison_column}{year-1}\"]\n\n        remainder = total_funding - sub_sa[\"alloc\"].sum()\n\n        sub_sa[\"alloc\"] += sub_sa[f\"Funding Gap_{year}\"] * remainder / total_funding_gap\n\n        sub_sa[\"delta\"] = (sub_sa[\"alloc\"] - sub_sa[f\"{comparison_column}{year-1}\"]) / sub_sa[f\"{comparison_column}{year-1}\"] * 100\n    return sub_sa\n\nThis function enforces South Australia’s cap/collar policy, ensuring councils’ year-on-year changes remain within the [-15%, 30%] range. It iteratively adjusts allocations to meet these constraints.\n\nsa_grants_base = pd.read_excel(\"../Data/FA Grants Tables - Python.xlsx\", sheet_name=\"South Australia\")\n\nsa_grants_base[\"ERP_2025\"] = sa_grants_base[\"ERP_2024\"] * pop_30_jun[\"SA\"][2025] / sa_grants_base[\"ERP_2024\"].sum()\nsa_grants_base[\"ERP_2025\"] = sa_grants_base[\"ERP_2025\"].round(0)\n\nsa_grants_base[\"ERP_2026\"] = sa_grants_base[\"ERP_2024\"] * pop_30_jun[\"SA\"][2026] / sa_grants_base[\"ERP_2024\"].sum()\nsa_grants_base[\"ERP_2026\"] = sa_grants_base[\"ERP_2026\"].round(0)\n\nsa_grants_base[\"ERP_2027\"] = sa_grants_base[\"ERP_2024\"] * pop_30_jun[\"SA\"][2027] / sa_grants_base[\"ERP_2024\"].sum()\nsa_grants_base[\"ERP_2027\"] = sa_grants_base[\"ERP_2027\"].round(0)\n\nsa_grants_base[\"ERP_2028\"] = sa_grants_base[\"ERP_2024\"] * pop_30_jun[\"SA\"][2028] / sa_grants_base[\"ERP_2024\"].sum()\nsa_grants_base[\"ERP_2028\"] = sa_grants_base[\"ERP_2028\"].round(0)\n\nsa_grants_base[\"Grant_base_2024\"] = sa_grants_base[\"Grant_2024\"]\n\nsouth_australia_master_sim = pd.DataFrame()\n\nfor i in range(1000):\n    sa_grants = sa_grants_base.copy()\n\n    sa_grants[\"UID\"] = sa_grants[\"LGA\"].str.replace(\" \", \"\").replace(\"-\", \"\") + str(i+1)\n\n    for year in range(2025, 2029):\n        prev_year = year - 1\n\n        min_per_capita_grant = budget_grants[\"SA\"][f\"{year}-{(year+1)%1000}\"] / sa_grants[f\"ERP_{year}\"].sum() * per_capita_minimum\n\n        min_grant = sa_grants[f\"ERP_{year}\"] * min_per_capita_grant\n\n        min_per_capita_grant_base = budget_grants[\"SA\"][f\"{year}-{(year+1)%1000}\"] / sa_grants[f\"ERP_{year}\"].sum() * per_capita_minimum_base\n\n        min_grant_base = sa_grants[f\"ERP_{year}\"] * min_per_capita_grant_base\n\n        sa_grants[f\"Funding Gap_{year}\"] = sa_grants[f\"Funding Gap_{year-1}\"] * np.random.normal(1, 0.1, size=sa_grants.shape[0])\n\n        sa_grants[\"deficit\"] = sa_grants[f\"Funding Gap_{year}\"] &gt; 0\n\n        total_deficit = (sa_grants[f\"Funding Gap_{year}\"] * sa_grants[\"deficit\"]).sum()\n\n        # New case\n\n        raw_alloc = (sa_grants[f\"Funding Gap_{year}\"] * sa_grants[\"deficit\"] / total_deficit) * (budget_grants[\"SA\"][f\"{year}-{(year+1)%1000}\"] - min_grant.sum())\n\n        sa_grants[\"alloc\"] = min_grant + raw_alloc\n\n        sa_grants[\"delta\"] = (sa_grants[\"alloc\"] - sa_grants[f\"Grant_{year-1}\"]) / sa_grants[f\"Grant_{year-1}\"] * 100\n\n        non_min_sa = sa_grants[sa_grants[\"deficit\"]]#[[\"LGA\", f\"Funding Gap_{year}\", f\"grant_{year-1}\", \"alloc\"]]\n\n        sa_grants.combine_first(correct_delta_sa(non_min_sa, year))\n\n        sa_grants[f\"Grant_{year}\"] = sa_grants[\"alloc\"]\n\n        # Base case\n\n        raw_alloc = (sa_grants[f\"Funding Gap_{year}\"] * sa_grants[\"deficit\"] / total_deficit) * (budget_grants[\"SA\"][f\"{year}-{(year+1)%1000}\"] - min_grant_base.sum())\n\n        sa_grants[\"alloc\"] = min_grant_base + raw_alloc\n\n        sa_grants[\"delta\"] = (sa_grants[\"alloc\"] - sa_grants[f\"Grant_base_{year-1}\"]) / sa_grants[f\"Grant_base_{year-1}\"] * 100\n\n        non_min_sa = sa_grants[sa_grants[\"deficit\"]]#[[\"LGA\", f\"Funding Gap_{year}\", f\"grant_{year-1}\", \"alloc\"]]\n\n        sa_grants.combine_first(correct_delta_sa(non_min_sa, year, base=True))\n\n        sa_grants[f\"Grant_base_{year}\"] = sa_grants[\"alloc\"]\n    \n    south_australia_master_sim = pd.concat([south_australia_master_sim, sa_grants])\n\nThis cell simulates grant allocations for South Australia, applying the cap/collar function to all councils. It projects population, calculates minimum grants, and distributes the remaining budget based on funding gaps, running 1000 simulations.",
    "crumbs": [
      "Data Data Data",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Methodology: Grants Simulation</span>"
    ]
  },
  {
    "objectID": "simulation_methodology.html#western-australia",
    "href": "simulation_methodology.html#western-australia",
    "title": "12  Methodology: Grants Simulation",
    "section": "12.6 Western Australia",
    "text": "12.6 Western Australia\nWA State Grants Commission has no ceiling on change, but claims to limit year on year decrease. No explicit floor is given, but the biggest 2023-24 to 2024-25 decrease was about -60%. So, that’s the floor we’ll use.\n\ndef correct_delta_wa(sub_wa, year, base = False):\n\n    total_funding_gap =  (sub_wa[f\"Funding Gap_{year}\"] * sub_wa[\"deficit\"]).sum()\n    total_funding = sub_wa[\"alloc\"].sum()\n\n    comparison_column = \"Grant_base_\" if base else \"Grant_\"\n    \n    while np.any((sub_wa[\"delta\"].round(2)&lt;-60)):\n        sub_wa[\"g\"] = sub_wa[\"delta\"].apply(lambda x: (x - (-60))/100 if x &lt; -60 else 0)\n\n        sub_wa[\"alloc\"] -= sub_wa[\"g\"] * sub_wa[f\"{comparison_column}{year-1}\"]\n\n        remainder = total_funding - sub_wa[\"alloc\"].sum()\n\n        sub_wa[\"alloc\"] += sub_wa[f\"Funding Gap_{year}\"] * remainder / total_funding_gap\n\n        sub_wa[\"delta\"] = (sub_wa[\"alloc\"] - sub_wa[f\"{comparison_column}{year-1}\"]) / sub_wa[f\"{comparison_column}{year-1}\"] * 100\n    return sub_wa\n\nThis function enforces Western Australia’s floor on year-on-year decreases, setting a minimum change of -60%. It iteratively adjusts allocations to ensure no council’s grant decreases by more than this threshold.\n\nwa_grants_base = pd.read_excel(\"../Data/FA Grants Tables - Python.xlsx\", sheet_name=\"Western Australia\")\n\nwa_grants_base[\"ERP_2025\"] = wa_grants_base[\"ERP_2024\"] * pop_30_jun[\"WA\"][2025] / wa_grants_base[\"ERP_2024\"].sum()\nwa_grants_base[\"ERP_2025\"] = wa_grants_base[\"ERP_2025\"].round(0)\n\nwa_grants_base[\"ERP_2026\"] = wa_grants_base[\"ERP_2024\"] * pop_30_jun[\"WA\"][2026] / wa_grants_base[\"ERP_2024\"].sum()\nwa_grants_base[\"ERP_2026\"] = wa_grants_base[\"ERP_2026\"].round(0)\n\nwa_grants_base[\"ERP_2027\"] = wa_grants_base[\"ERP_2024\"] * pop_30_jun[\"WA\"][2027] / wa_grants_base[\"ERP_2024\"].sum()\nwa_grants_base[\"ERP_2027\"] = wa_grants_base[\"ERP_2027\"].round(0)\n\nwa_grants_base[\"ERP_2028\"] = wa_grants_base[\"ERP_2024\"] * pop_30_jun[\"WA\"][2028] / wa_grants_base[\"ERP_2024\"].sum()\nwa_grants_base[\"ERP_2028\"] = wa_grants_base[\"ERP_2028\"].round(0)\n\nwa_grants_base[\"Grant_base_2024\"] = wa_grants_base[\"Grant_2024\"]\n\nwestern_australia_master_sim = pd.DataFrame()\n\nfor i in range(1000):\n    wa_grants = wa_grants_base.copy()\n\n    wa_grants[\"UID\"] = wa_grants[\"LGA\"].str.replace(\" \", \"\").replace(\"-\", \"\") + str(i+1)\n\n    for year in range(2025, 2029):\n        prev_year = year - 1\n\n        min_per_capita_grant = budget_grants[\"WA\"][f\"{year}-{(year+1)%1000}\"] / wa_grants[f\"ERP_{year}\"].sum() * per_capita_minimum\n\n        min_grant = wa_grants[f\"ERP_{year}\"] * min_per_capita_grant\n\n        min_per_capita_grant_base = budget_grants[\"WA\"][f\"{year}-{(year+1)%1000}\"] / wa_grants[f\"ERP_{year}\"].sum() * per_capita_minimum_base\n\n        min_grant_base = wa_grants[f\"ERP_{year}\"] * min_per_capita_grant_base\n\n        wa_grants[f\"Funding Gap_{year}\"] = wa_grants[f\"Funding Gap_{year-1}\"] * np.random.normal(1, 0.1, size=wa_grants.shape[0])\n\n        wa_grants[\"deficit\"] = wa_grants[f\"Funding Gap_{year}\"] &gt; 0\n\n        total_deficit = (wa_grants[f\"Funding Gap_{year}\"] * wa_grants[\"deficit\"]).sum()\n\n        # New case\n\n        raw_alloc = (wa_grants[f\"Funding Gap_{year}\"] * wa_grants[\"deficit\"] / total_deficit) * (budget_grants[\"WA\"][f\"{year}-{(year+1)%1000}\"] - min_grant.sum())\n\n        wa_grants[\"alloc\"] = min_grant + raw_alloc\n\n        wa_grants[\"delta\"] = (wa_grants[\"alloc\"] - wa_grants[f\"Grant_{year-1}\"]) / wa_grants[f\"Grant_{year-1}\"] * 100\n\n        non_min_wa = wa_grants[wa_grants[\"deficit\"]]#[[\"LGA\", f\"Funding Gap_{year}\", f\"grant_{year-1}\", \"alloc\"]]\n\n        wa_grants.combine_first(correct_delta_wa(non_min_wa, year))\n\n        wa_grants[f\"Grant_{year}\"] = wa_grants[\"alloc\"]\n\n        # Base case\n\n        raw_alloc = (wa_grants[f\"Funding Gap_{year}\"] * wa_grants[\"deficit\"] / total_deficit) * (budget_grants[\"WA\"][f\"{year}-{(year+1)%1000}\"] - min_grant_base.sum())\n\n        wa_grants[\"alloc\"] = min_grant_base + raw_alloc\n\n        wa_grants[\"delta\"] = (wa_grants[\"alloc\"] - wa_grants[f\"Grant_base_{year-1}\"]) / wa_grants[f\"Grant_base_{year-1}\"] * 100\n\n        non_min_wa = wa_grants[wa_grants[\"deficit\"]]#[[\"LGA\", f\"Funding Gap_{year}\", f\"grant_{year-1}\", \"alloc\"]]\n\n        wa_grants.combine_first(correct_delta_wa(non_min_wa, year, base=True))\n\n        wa_grants[f\"Grant_base_{year}\"] = wa_grants[\"alloc\"]\n    \n    western_australia_master_sim = pd.concat([western_australia_master_sim, wa_grants])\n\nThis cell simulates grant allocations for Western Australia, applying the floor function to all councils. It projects population, calculates minimum grants, and distributes the remaining budget based on funding gaps, running 1000 simulations.",
    "crumbs": [
      "Data Data Data",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Methodology: Grants Simulation</span>"
    ]
  },
  {
    "objectID": "simulation_methodology.html#tasmania",
    "href": "simulation_methodology.html#tasmania",
    "title": "12  Methodology: Grants Simulation",
    "section": "12.7 Tasmania",
    "text": "12.7 Tasmania\nTasmania State Grants Commission has a cap/collar of [-5%, 10%] for all councils.\n\ndef correct_delta_tas(sub_tas, year, base = False):\n\n    total_funding_gap =  (sub_tas[f\"Funding Gap_{year}\"] * sub_tas[\"deficit\"]).sum()\n    total_funding = sub_tas[\"alloc\"].sum()\n\n    comparison_column = \"Grant_base_\" if base else \"Grant_\"\n    \n    while np.any((sub_tas[\"delta\"].round(2)&lt;-5)|(sub_tas[\"delta\"].round(2)&gt;10)):\n        print(sub_tas[\"delta\"].min(), sub_tas[\"delta\"].mean(), sub_tas[\"delta\"].max())\n        sub_tas[\"g\"] = sub_tas[\"delta\"].apply(lambda x: (x - (-5))/100 if x &lt; -5 else ((x - 10)/100 if x &gt; 10 else 0))\n\n        sub_tas[\"alloc\"] -= sub_tas[\"g\"] * sub_tas[f\"{comparison_column}{year-1}\"]\n\n        remainder = total_funding - sub_tas[\"alloc\"].sum()\n\n        sub_tas[\"alloc\"] += sub_tas[f\"Funding Gap_{year}\"] * remainder / total_funding_gap\n\n        delta_new = (sub_tas[\"alloc\"] - sub_tas[f\"{comparison_column}{year-1}\"]) / sub_tas[f\"{comparison_column}{year-1}\"] * 100\n\n        if delta_new.round(3).equals(sub_tas[\"delta\"].round(3)):\n            sub_tas[\"delta\"] = delta_new\n            break\n\n        sub_tas[\"delta\"] = delta_new\n\n    return sub_tas\n\nThis function enforces Tasmania’s cap/collar policy, ensuring all councils’ year-on-year changes remain within the [-5%, 10%] range. It iteratively adjusts allocations to comply with these constraints.\n\ntas_grants_base = pd.read_excel(\"../Data/FA Grants Tables - Python.xlsx\", sheet_name=\"Tasmania\")\n\ntas_grants_base[\"ERP_2025\"] = tas_grants_base[\"ERP_2024\"] * pop_30_jun[\"TAS\"][2025] / tas_grants_base[\"ERP_2024\"].sum()\ntas_grants_base[\"ERP_2025\"] = tas_grants_base[\"ERP_2025\"].round(0)\n\ntas_grants_base[\"ERP_2026\"] = tas_grants_base[\"ERP_2024\"] * pop_30_jun[\"TAS\"][2026] / tas_grants_base[\"ERP_2024\"].sum()\ntas_grants_base[\"ERP_2026\"] = tas_grants_base[\"ERP_2026\"].round(0)\n\ntas_grants_base[\"ERP_2027\"] = tas_grants_base[\"ERP_2024\"] * pop_30_jun[\"TAS\"][2027] / tas_grants_base[\"ERP_2024\"].sum()\ntas_grants_base[\"ERP_2027\"] = tas_grants_base[\"ERP_2027\"].round(0)\n\ntas_grants_base[\"ERP_2028\"] = tas_grants_base[\"ERP_2024\"] * pop_30_jun[\"TAS\"][2028] / tas_grants_base[\"ERP_2024\"].sum()\ntas_grants_base[\"ERP_2028\"] = tas_grants_base[\"ERP_2028\"].round(0)\n\ntas_grants_base[\"Grant_base_2024\"] = tas_grants_base[\"Grant_2024\"]\n\ntasmania_master_sim = pd.DataFrame()\n\nfor i in range(1000):\n    tas_grants = tas_grants_base.copy()\n\n    tas_grants[\"UID\"] = tas_grants[\"LGA\"].str.replace(\" \", \"\").replace(\"-\", \"\") + str(i+1)\n\n    for year in range(2025, 2029):\n        prev_year = year - 1\n\n        min_per_capita_grant = budget_grants[\"TAS\"][f\"{year}-{(year+1)%1000}\"] / tas_grants[f\"ERP_{year}\"].sum() * per_capita_minimum\n\n        min_grant = tas_grants[f\"ERP_{year}\"] * min_per_capita_grant\n\n        min_per_capita_grant_base = budget_grants[\"TAS\"][f\"{year}-{(year+1)%1000}\"] / tas_grants[f\"ERP_{year}\"].sum() * per_capita_minimum_base\n\n        min_grant_base = tas_grants[f\"ERP_{year}\"] * min_per_capita_grant_base\n\n        tas_grants[f\"Funding Gap_{year}\"] = tas_grants[f\"Funding Gap_{year-1}\"] * np.random.normal(1, 0.1, size=tas_grants.shape[0])\n\n        tas_grants[\"deficit\"] = tas_grants[f\"Funding Gap_{year}\"] &gt; 0\n\n        total_deficit = (tas_grants[f\"Funding Gap_{year}\"] * tas_grants[\"deficit\"]).sum()\n\n\n        # New case\n\n        raw_alloc = (tas_grants[f\"Funding Gap_{year}\"] * tas_grants[\"deficit\"] / total_deficit) * (budget_grants[\"TAS\"][f\"{year}-{(year+1)%1000}\"] - min_grant.sum())\n\n        tas_grants[\"alloc\"] = min_grant + raw_alloc\n\n\n        tas_grants[\"delta\"] = (tas_grants[\"alloc\"] - tas_grants[f\"Grant_{year-1}\"]) / tas_grants[f\"Grant_{year-1}\"] * 100\n\n        non_min_tas = tas_grants[tas_grants[\"deficit\"]]#[[\"LGA\", f\"Funding Gap_{year}\", f\"grant_{year-1}\", \"alloc\"]]\n\n\n        tas_grants.combine_first(correct_delta_tas(non_min_tas, year))\n\n        tas_grants[f\"Grant_{year}\"] = tas_grants[\"alloc\"]\n\n\n        # Base case\n\n        raw_alloc = (tas_grants[f\"Funding Gap_{year}\"] * tas_grants[\"deficit\"] / total_deficit) * (budget_grants[\"TAS\"][f\"{year}-{(year+1)%1000}\"] - min_grant_base.sum())\n\n        tas_grants[\"alloc\"] = min_grant_base + raw_alloc\n\n        tas_grants[\"delta\"] = (tas_grants[\"alloc\"] - tas_grants[f\"Grant_base_{year-1}\"]) / tas_grants[f\"Grant_base_{year-1}\"] * 100\n\n        non_min_tas = tas_grants[tas_grants[\"deficit\"]]#[[\"LGA\", f\"Funding Gap_{year}\", f\"grant_{year-1}\", \"alloc\"]]\n\n        tas_grants.combine_first(correct_delta_tas(non_min_tas, year, base=True))\n\n        tas_grants[f\"Grant_base_{year}\"] = tas_grants[\"alloc\"]\n\n    tasmania_master_sim = pd.concat([tasmania_master_sim, tas_grants])\n\nThis cell simulates grant allocations for Tasmania, applying the cap/collar function to all councils. It projects population, calculates minimum grants, and distributes the remaining budget based on funding gaps, running 1000 simulations.",
    "crumbs": [
      "Data Data Data",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Methodology: Grants Simulation</span>"
    ]
  },
  {
    "objectID": "simulation_methodology.html#northern-territory",
    "href": "simulation_methodology.html#northern-territory",
    "title": "12  Methodology: Grants Simulation",
    "section": "12.8 Northern Territory",
    "text": "12.8 Northern Territory\nNorthern Territory has a collar of -5% for all councils.\n\ndef correct_delta_nt(sub_nt, year, base = False):\n\n    total_funding_gap =  ( sub_nt[f\"Funding Gap_{year}\"] * sub_nt[\"deficit\"]).sum()\n    total_funding = sub_nt[\"alloc\"].sum()\n    \n    comparison_column = \"Grant_base_\" if base else \"Grant_\"\n\n    while np.any((sub_nt[\"delta\"].round(2)&lt;-5)):\n        sub_nt[\"g\"] = sub_nt[\"delta\"].apply(lambda x: (x - (-5))/100 if x &lt; -5 else 0)\n\n        sub_nt[\"alloc\"] -= sub_nt[\"g\"] * sub_nt[f\"{comparison_column}{year-1}\"]\n\n        remainder = total_funding - sub_nt[\"alloc\"].sum()\n\n        sub_nt[\"alloc\"] += sub_nt[f\"Funding Gap_{year}\"] * remainder / total_funding_gap\n\n        sub_nt[\"delta\"] = (sub_nt[\"alloc\"] - sub_nt[f\"{comparison_column}{year-1}\"]) / sub_nt[f\"{comparison_column}{year-1}\"] * 100\n    return sub_nt\n\nThis function enforces Northern Territory’s collar policy, ensuring all councils’ year-on-year changes do not fall below -5%. It iteratively adjusts allocations to meet this constraint.\n\nnt_grants_base = pd.read_excel(\"../Data/FA Grants Tables - Python.xlsx\", sheet_name=\"Northern Territory\")\n\nnt_grants_base[\"ERP_2025\"] = nt_grants_base[\"ERP_2024\"] * pop_30_jun[\"NT\"][2025] / nt_grants_base[\"ERP_2024\"].sum()\nnt_grants_base[\"ERP_2025\"] = nt_grants_base[\"ERP_2025\"].round(0)\n\nnt_grants_base[\"ERP_2026\"] = nt_grants_base[\"ERP_2024\"] * pop_30_jun[\"NT\"][2026] / nt_grants_base[\"ERP_2024\"].sum()\nnt_grants_base[\"ERP_2026\"] = nt_grants_base[\"ERP_2026\"].round(0)\n\nnt_grants_base[\"ERP_2027\"] = nt_grants_base[\"ERP_2024\"] * pop_30_jun[\"NT\"][2027] / nt_grants_base[\"ERP_2024\"].sum()\nnt_grants_base[\"ERP_2027\"] = nt_grants_base[\"ERP_2027\"].round(0)\n\nnt_grants_base[\"ERP_2028\"] = nt_grants_base[\"ERP_2024\"] * pop_30_jun[\"NT\"][2028] / nt_grants_base[\"ERP_2024\"].sum()\nnt_grants_base[\"ERP_2028\"] = nt_grants_base[\"ERP_2028\"].round(0)\n\nnt_grants_base[\"Grant_base_2024\"] = nt_grants_base[\"Grant_2024\"]\n\nnorthern_territory_master_sim = pd.DataFrame()\n\nfor i in range(1000):\n    nt_grants = nt_grants_base.copy()\n\n    nt_grants[\"UID\"] = nt_grants[\"LGA\"].str.replace(\" \", \"\").replace(\"-\", \"\") + str(i+1)\n\n    for year in range(2025, 2029):\n        prev_year = year - 1\n\n        min_per_capita_grant = budget_grants[\"NT\"][f\"{year}-{(year+1)%1000}\"] / nt_grants[f\"ERP_{year}\"].sum() * per_capita_minimum\n\n        min_grant = nt_grants[f\"ERP_{year}\"] * min_per_capita_grant\n\n        min_per_capita_grant_base = budget_grants[\"NT\"][f\"{year}-{(year+1)%1000}\"] / nt_grants[f\"ERP_{year}\"].sum() * per_capita_minimum_base\n\n        min_grant_base = nt_grants[f\"ERP_{year}\"] * min_per_capita_grant_base\n\n        nt_grants[f\"Funding Gap_{year}\"] = nt_grants[f\"Funding Gap_{year-1}\"] * np.random.normal(1, 0.1, size=nt_grants.shape[0])\n\n        nt_grants[\"deficit\"] = nt_grants[f\"Funding Gap_{year}\"] &gt; 0\n\n        total_deficit = (nt_grants[f\"Funding Gap_{year}\"] * nt_grants[\"deficit\"]).sum()\n\n        # New case\n\n        raw_alloc = (nt_grants[f\"Funding Gap_{year}\"] * nt_grants[\"deficit\"] / total_deficit) * (budget_grants[\"NT\"][f\"{year}-{(year+1)%1000}\"] - min_grant.sum())\n\n        nt_grants[\"alloc\"] = min_grant + raw_alloc\n\n        nt_grants[\"delta\"] = (nt_grants[\"alloc\"] - nt_grants[f\"Grant_{year-1}\"]) / nt_grants[f\"Grant_{year-1}\"] * 100\n\n        non_min_nt = nt_grants[nt_grants[\"deficit\"]]#[[\"LGA\", f\"Funding Gap_{year}\", f\"grant_{year-1}\", \"alloc\"]]\n\n        nt_grants.combine_first(correct_delta_nt(non_min_nt, year))\n\n        nt_grants[f\"Grant_{year}\"] = nt_grants[\"alloc\"]\n\n        # Base case\n\n        raw_alloc = (nt_grants[f\"Funding Gap_{year}\"] * nt_grants[\"deficit\"] / total_deficit) * (budget_grants[\"NT\"][f\"{year}-{(year+1)%1000}\"] - min_grant_base.sum())\n\n        nt_grants[\"alloc\"] = min_grant_base + raw_alloc\n\n        nt_grants[\"delta\"] = (nt_grants[\"alloc\"] - nt_grants[f\"Grant_base_{year-1}\"]) / nt_grants[f\"Grant_base_{year-1}\"] * 100\n\n        non_min_nt = nt_grants[nt_grants[\"deficit\"]]#[[\"LGA\", f\"Funding Gap_{year}\", f\"grant_{year-1}\", \"alloc\"]]\n\n        nt_grants.combine_first(correct_delta_nt(non_min_nt, year, base=True))\n\n        nt_grants[f\"Grant_base_{year}\"] = nt_grants[\"alloc\"]\n\n    northern_territory_master_sim = pd.concat([northern_territory_master_sim, nt_grants])\n\n100%|██████████| 1000/1000 [00:36&lt;00:00, 27.52it/s]\n\n\nThis cell simulates grant allocations for Northern Territory, applying the collar function to all councils. It projects population, calculates minimum grants, and distributes the remaining budget based on funding gaps, running 1000 simulations.",
    "crumbs": [
      "Data Data Data",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>Methodology: Grants Simulation</span>"
    ]
  }
]